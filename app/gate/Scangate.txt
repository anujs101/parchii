// app/gate/ScanPage.tsx
'use client';

import React, { useEffect, useRef, useState, useCallback } from 'react';
import SignClient from '@walletconnect/sign-client';
import type { SessionTypes } from "@walletconnect/types";
import QRCode from 'qrcode';
import bs58 from 'bs58';

import QRScanner from '@/components/qr/QRScanner';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { WalletConnectButton } from '@/components/wallet/WalletConnectButton';
import { CheckCircle, AlertCircle, QrCode } from 'lucide-react';

type ScanResponse = {
  ok: boolean;
  challengeJwt?: string;
  messageToSign?: string;
  expiresInSeconds?: number;
  verificationId?: string | null;
  ticketId?: string;
  eventId?: string | null;
  error?: string;
  details?: string;
};

const WALLETCONNECT_PROJECT_ID = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID ?? '';

// normalize incoming chain id so we don't accidentally double-prefix
function ensureCaipChain(namespace: string, chainLike: string) {
  const pref = `${namespace}:`;
  if (!chainLike) return `${namespace}:`; // defensive
  // if already starts with the namespace (e.g. "solana:...") return as-is
  if (chainLike.startsWith(pref)) return chainLike;
  // if the value already contains namespace twice (very defensive), strip extras
  const stripped = chainLike.replace(new RegExp(`^(?:${namespace}:)+`), '');
  return `${namespace}:${stripped}`;
}
// get devnet genesis (run once at runtime)
async function getSolanaGenesisHash(rpcUrl = 'https://api.devnet.solana.com') {
  const r = await fetch(rpcUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'getGenesisHash' }),
  });
  const j = await r.json();
  return j?.result; // example: "GH7ome3Ei..." (whatever the node returns)
}

export default function ScanPage() {
  // UI state
  const [lastScan, setLastScan] = useState<string | null>(null);
  const [status, setStatus] = useState<'idle' | 'processing' | 'success' | 'error'>('idle');
  const [message, setMessage] = useState<string>('Scan a ticket QR to verify');
  const [manualText, setManualText] = useState<string>('');

  // Gate flow state
  const [challengeJwt, setChallengeJwt] = useState<string | null>(null);
  const [messageToSign, setMessageToSign] = useState<string | null>(null);
  const [expiresIn, setExpiresIn] = useState<number | null>(null);
  const [verificationId, setVerificationId] = useState<string | null>(null);
  const [ticketId, setTicketId] = useState<string | null>(null);

  // WalletConnect UI
  const [wcQrDataUrl, setWcQrDataUrl] = useState<string | null>(null);
  const [wcStatus, setWcStatus] = useState<string | null>(null);

  // Signature state
  const [signature, setSignature] = useState<string | null>(null);
  const [signerPubkey, setSignerPubkey] = useState<string | null>(null);

  // Busy / error states
  const [busy, setBusy] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // WalletConnect client refs
  const clientRef = useRef<SignClient | null>(null);
  const sessionTopicRef = useRef<string | null>(null);

  const STAFF_ID = 'staff-1';
  const GATE_ID = 'gate-1';

  // cleanup on unmount
  useEffect(() => {
    return () => {
      (async () => {
        try {
          const client = clientRef.current;
          const topic = sessionTopicRef.current;
          if (client && topic) {
            try {
              await client.disconnect({
                topic,
                reason: { code: 6000, message: 'component_unmount' },
              });
            } catch (e) {
              // ignore
            }
          }
        } catch {}
        clientRef.current = null;
        sessionTopicRef.current = null;
      })();
    };
  }, []);

  // --- API: scan ---
  const callScanApi = useCallback(async (qrString: string) => {
    setBusy(true);
    setError(null);
    setSignature(null);
    setSignerPubkey(null);
    setVerifyResult(null);

    try {
      const res = await fetch('/api/gate/scan', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ qrString, staffId: STAFF_ID, gateId: GATE_ID }),
      });
      const data: ScanResponse = await res.json();
      if (!data.ok) throw new Error(data.error || data.details || 'scan_failed');

      setChallengeJwt(data.challengeJwt ?? null);
      setMessageToSign(data.messageToSign ?? null);
      setExpiresIn(data.expiresInSeconds ?? null);
      setVerificationId(data.verificationId ?? null);
      setTicketId(data.ticketId ?? null);

      return data;
    } catch (err: any) {
      console.error('scan api error', err);
      setError(err?.message ?? 'scan_error');
      throw err;
    } finally {
      setBusy(false);
    }
  }, []);

  // --- API: verify ---
  const callVerifyApi = useCallback(async (payload: {
    challengeJwt: string;
    signatureBase58: string;
    signerPubkey?: string | null;
    staffId?: string;
    gateId?: string;
    verificationId?: string | null;
  }) => {
    setBusy(true);
    setError(null);
    setVerifyResult(null);
    try {
      const res = await fetch('/api/gate/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const data = await res.json();
      if (!data.ok) {
        setVerifyResult({ ok: false, error: data.error, details: data.details });
        throw new Error(data.error || 'verify_failed');
      }
      setVerifyResult(data);
      return data;
    } catch (err: any) {
      console.error('verify api error', err);
      setError(err?.message ?? 'verify_error');
      throw err;
    } finally {
      setBusy(false);
    }
  }, []);

  // small local storage for verify result to display
  const [verifyResult, setVerifyResult] = useState<any>(null);
  

  // --- WalletConnect helpers ---
async function initWalletConnectClient() {
  if (!WALLETCONNECT_PROJECT_ID) throw new Error('WalletConnect Project ID not configured');
  if (clientRef.current) return clientRef.current;
  // defensive: guard global to avoid repeated init across HMR reloads
  // @ts-ignore
  if ((window as any).__WALLETCONNECT_CLIENT_INITIALIZING) {
    // wait briefly for that init to finish
    await new Promise((res) => setTimeout(res, 200));
    if (clientRef.current) return clientRef.current;
  }
  // @ts-ignore
  (window as any).__WALLETCONNECT_CLIENT_INITIALIZING = true;
  try {
    const client = await SignClient.init({ projectId: WALLETCONNECT_PROJECT_ID });
    clientRef.current = client;
    client.on?.('session_delete', () => {
      sessionTopicRef.current = null;
      setWcStatus('disconnected');
    });
    return client;
  } finally {
    // @ts-ignore
    (window as any).__WALLETCONNECT_CLIENT_INITIALIZING = false;
  }
}


  // start pairing, request sign, return { signature, pubkey }
  async function startWalletConnectAndSign(messageToSignStr: string) {
    setBusy(true);
    setError(null);
    setSignature(null);
    setSignerPubkey(null);
    setWcQrDataUrl(null);
    setWcStatus('initializing');

    try {
      const client = await initWalletConnectClient();
      const genesis = await getSolanaGenesisHash();
      console.log('solana genesisHash from RPC:', genesis);
      const SOLANA_DEVNET_CAIP = `solana:${genesis}`;
      console.log('Using CAIP chain:', SOLANA_DEVNET_CAIP);

      const solChain = ensureCaipChain('solana', SOLANA_DEVNET_CAIP); // idempotent
      const requiredNamespaces = {
        solana: {
          methods: ['solana_signMessage'],
          chains: [solChain],
          events: [],
        },
      };
        console.log('WalletConnect proposal (requiredNamespaces):', JSON.stringify(requiredNamespaces, null, 2));
      const { uri, approval } = await client.connect({ requiredNamespaces });

      if (!uri) throw new Error('WalletConnect pairing URI not returned');
      setWcStatus('paired_waiting');


      // render QR
      const dataUrl = await QRCode.toDataURL(uri);
      setWcQrDataUrl(dataUrl);

      // approval timeout to avoid indefinite wait
      const APPROVAL_TIMEOUT_MS = 90_000;
      const approvalPromise = approval();
      const timeoutPromise = new Promise((_res, rej) =>
        setTimeout(() => rej(new Error('wallet_approval_timeout')), APPROVAL_TIMEOUT_MS)
      );

      // wait once and handle errors cleanly
      let session: SessionTypes.Struct;
      try {
        session = await Promise.race([approvalPromise, timeoutPromise]) as SessionTypes.Struct;
      } catch (err) {
        console.error('approval error / timeout:', err);
        throw err; // bubble up so your outer catch shows the actual reason
      }

      console.log('session.namespaces:', JSON.stringify(session.namespaces, null, 2));
      const acceptedChains = (session.namespaces?.solana?.chains ?? []) as string[];
      // defensive check: did wallet accept our chain?
      console.log('acceptedChains by wallet:', acceptedChains);
      if (!acceptedChains.includes(solChain)) {
        // show the wallet's accepted chains in UI and throw
        const accepted = acceptedChains.length ? acceptedChains.join(', ') : 'none';
        throw new Error(`Wallet did not accept requested chain ${solChain}. Wallet accepted: ${accepted}`);
      }

      
      
      sessionTopicRef.current = session.topic;
      setWcStatus('connected');

              // prepare two payloads to try
        const messageBytes = Array.from(new TextEncoder().encode(messageToSignStr));
        const messageBase64 = btoa(messageToSignStr);

        // first try bytes (array)
        let rawRes: unknown;
        try {
          rawRes = await client.request({
            topic: session.topic,
            chainId: solChain,
            request: { method: 'solana_signMessage', params: { message: messageBytes } },
          } as any);
          console.log('sign with bytes succeeded');
        } catch (err1) {
          console.warn('sign with bytes failed, trying base64', err1);
          // try base64 fallback
          rawRes = await client.request({
            topic: session.topic,
            chainId: solChain,
            request: { method: 'solana_signMessage', params: { message: messageBase64 } },
          } as any);
          console.log('sign with base64 succeeded');
        }


      setWcStatus('requesting_signature');

      //const rawRes: unknown = await client.request(request as any);

      // parse response (Phantom priority)
      let sig: string | null = null;
      let pubkey: string | null = null;

      const isObject = (v: unknown): v is Record<string, unknown> =>
        typeof v === 'object' && v !== null;

      if (isObject(rawRes) && typeof (rawRes as any).signature === 'string') {
        sig = (rawRes as any).signature;
        if (typeof (rawRes as any).pubkey === 'string') pubkey = (rawRes as any).pubkey;
      }

      if (!sig) {
        if (typeof rawRes === 'string') sig = rawRes;
        else if (Array.isArray(rawRes)) {
          if (typeof rawRes[0] === 'string') sig = rawRes[0];
          if (typeof rawRes[1] === 'string') pubkey = rawRes[1];
        } else if (isObject(rawRes)) {
          if ('result' in rawRes) {
            const r = (rawRes as any).result;
            if (typeof r === 'string') sig = r;
            else if (isObject(r) && typeof r.signature === 'string') {
              sig = r.signature;
              if (typeof r.pubkey === 'string') pubkey = r.pubkey;
            } else if (Array.isArray(r) && typeof r[0] === 'string') {
              sig = r[0];
              if (typeof r[1] === 'string') pubkey = r[1];
            }
          } else if ('signed' in rawRes && typeof (rawRes as any).signed === 'string') {
            sig = (rawRes as any).signed;
            if (typeof (rawRes as any).pubkey === 'string') pubkey = (rawRes as any).pubkey;
          } else if ('signature' in rawRes && typeof (rawRes as any).signature === 'object') {
            const s = (rawRes as any).signature;
            if (typeof s === 'string') sig = s;
          }
        }
      }
      console.log('sign result parsed:', { sig, pubkey });
      if (!sig) {
        console.warn('Wallet sign returned unexpected shape:', rawRes);
        throw new Error('no_signature_in_response');
      }

      setSignature(sig);
      if (pubkey) setSignerPubkey(pubkey);

      setWcStatus('signed');

      // disconnect session (single-use)
      try {
        await client.disconnect({ topic: session.topic, reason: { code: 6000, message: 'single-use finished' } });
        sessionTopicRef.current = null;
        setWcStatus('disconnected');
      } catch (e) {
        console.warn('wc disconnect error after sign', e);
      }

      return { signature: sig, pubkey: pubkey ?? null };
    } catch (err: any) {
      console.error('WalletConnect error', err);
      setError(err?.message ?? 'walletconnect_error');
      setWcStatus('error');
      throw err;
    } finally {
      setBusy(false);
    }
  }
// utils/base64url.ts (or inline)
function base64UrlToUtf8(base64url: string): string {
  // turn base64url into base64
  let b64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
  // add padding
  while (b64.length % 4) b64 += '=';
  // decode base64 into binary string
  const bin = atob(b64);
  // convert binary string to UTF-8
  const bytes = Uint8Array.from(bin.split('').map(ch => ch.charCodeAt(0)));
  const decoder = new TextDecoder('utf-8');
  return decoder.decode(bytes);
}
// // helper: decode base64url -> utf8
// function base64UrlToUtf8(base64url: string): string {
//   let b64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
//   while (b64.length % 4) b64 += '=';
//   const bin = atob(b64);
//   const bytes = Uint8Array.from(bin.split('').map(ch => ch.charCodeAt(0)));
//   return new TextDecoder('utf-8').decode(bytes);
// }

/**
 * Normalize scanned QR text into a JSON-string that /api/gate/scan understands.
 * Accepts:
 *  - raw JSON string already ({"t": "...", "m": "..."})
 *  - "parchi:<base64url>" format (decodes and maps short keys)
 */
function normalizeQrStringForServer(raw: string): string {
  const s = raw.trim();
  // handle parchi:<base64url>
  if (s.startsWith('parchi:')) {
    const payload = s.slice('parchi:'.length);
    try {
      const jsonText = base64UrlToUtf8(payload);
      const obj = JSON.parse(jsonText);
      // map short keys to server keys — send mint as `m`
      const mapped = {
        // keep fallback to existing names if generator already used them
        m: obj.a ?? obj.m ?? obj.mintPubkey ?? null,
        e: obj.e ?? obj.eventId ?? null,
        // t might be numeric ticketNumber — we still send it, server will use mint first
        t: obj.t ?? obj.ticketId ?? null,
        ts: obj.ts ?? null,
        c: obj.c ?? null,
      };
      return JSON.stringify(mapped);
    } catch (err) {
      // fallback: return original string so server can still try to parse/handle it
      return s;
    }
  }

  // already JSON or other: pass through
  return s;
}

function normalizeQrString(raw: string): string {
  const s = raw.trim();
  if (s.startsWith('parchi:')) {
    const payload = s.slice('parchi:'.length);
    try {
      const jsonText = base64UrlToUtf8(payload);
      // return JSON text that the server can parse
      return jsonText;
    } catch (err) {
      // fallback: return original to let server error out with details
      return s;
    }
  }
  return s;
}

  // --- Top-level flow: when a QR is scanned (camera or manual) ---
  const handleScan = useCallback(async (text: string) => {
  const normalized = normalizeQrStringForServer(text);
    if (!normalized) return;
    if (normalized === lastScan) return; // avoid duplicates
    setLastScan(normalized);
    setStatus('processing');
    setMessage('Verifying ticket...');

    try {
      // 1) call backend scan to get challenge after decoding the qr text
      const normalized = normalizeQrString(text);
      console.log('Normalized QR string for scan:', normalized);
         const scanData = await callScanApi(normalized);

      //  await callScanApi(normalized);

      // 2) get message to sign
      if (!scanData.messageToSign || !scanData.challengeJwt) {
        throw new Error('Invalid scan response');
      }

      // set UI debug info
      setChallengeJwt(scanData.challengeJwt);
      setMessageToSign(scanData.messageToSign);
      setVerificationId(scanData.verificationId ?? null);
      setExpiresIn(scanData.expiresInSeconds ?? null);
      setTicketId(scanData.ticketId ?? null);

      // 3) request wallet sign via WalletConnect (Phantom)
      const signRes = await startWalletConnectAndSign(scanData.messageToSign);

      // 4) call verify api with signature
      const verify = await callVerifyApi({
        challengeJwt: scanData.challengeJwt,
        signatureBase58: signRes.signature,
        signerPubkey: signRes.pubkey ?? undefined,
        staffId: STAFF_ID,
        gateId: GATE_ID,
        verificationId: scanData.verificationId ?? undefined,
      });

      // 5) show success or error
      if (verify.ok) {
        setStatus('success');
        setMessage(`Entry granted • Ticket ID ${verify.ticketId ?? scanData.ticketId ?? ''}`);
        setVerifyResult(verify);
      } else {
        setStatus('error');
        setMessage(verify.error ?? 'Verification failed');
        setVerifyResult(verify);
      }
    } catch (e: any) {
      const msg = e instanceof Error ? e.message : 'Verification error';
      setStatus('error');
      setMessage(msg);
    }
  }, [lastScan, callScanApi, callVerifyApi]);

  // Reset handler
  function doReset() {
    setLastScan(null);
    setStatus('idle');
    setMessage('Scan a ticket QR to verify');
    setManualText('');
    setChallengeJwt(null);
    setMessageToSign(null);
    setExpiresIn(null);
    setVerificationId(null);
    setTicketId(null);
    setWcQrDataUrl(null);
    setWcStatus(null);
    setSignature(null);
    setSignerPubkey(null);
    setVerifyResult(null);
    setError(null);
  }

  // countdown for expiresIn (UI only)
  useEffect(() => {
    if (!expiresIn) return;
    let remaining = expiresIn;
    setWcStatus((s) => s ?? 'challenge_issued');
    const iv = setInterval(() => {
      remaining -= 1;
      if (remaining <= 0) {
        setWcStatus('challenge_expired');
        clearInterval(iv);
      }
    }, 1000);
    return () => clearInterval(iv);
  }, [expiresIn]);

  return (
    <div className="min-h-screen bg-black py-8">
      <div className="max-w-4xl mx-auto px-4 space-y-6">
        <div className="flex items-center justify-between">
          <h1 className="text-xl font-semibold text-white">Gate Scanner</h1>
          <WalletConnectButton />
        </div>

        <Card className="bg-white/5 border-white/10">
          <CardContent className="p-4 grid md:grid-cols-2 gap-4">
            {/* left: camera scanner */}
            <div className="aspect-square bg-black/60 rounded-lg overflow-hidden flex items-center justify-center">
              <QRScanner
                onResult={(text) => {
                  // QRScanner might call rapidly, so debounce via lastScan check
                  handleScan(text).catch((e) => {
                    // handled in handleScan
                    console.warn('handleScan error', e);
                  });
                }}
                onError={(err) => {
                  if (status === 'idle') {
                    setStatus('error');
                    setMessage(typeof err === 'string' ? err : 'Scanner error');
                  }
                }}
                className="w-full h-full"
              />
            </div>

            {/* right: status + manual + walletconnect */}
            <div className="flex flex-col items-center justify-center text-center space-y-3 p-4">
              {status === 'success' && <CheckCircle className="w-12 h-12 text-emerald-400" />}
              {status === 'error' && <AlertCircle className="w-12 h-12 text-red-400" />}
              {status === 'idle' && <QrCode className="w-12 h-12 text-cyan-400" />}
              {status === 'processing' && <QrCode className="w-12 h-12 animate-pulse text-white" />}

              <p className="text-white/80">{message}</p>

              <div className="w-full space-y-2 pt-2">
                <Input
                  value={manualText}
                  onChange={(e) => setManualText(e.target.value)}
                  placeholder='Paste QR text here (e.g., {"t":"ticketId","m":"mintPubkey"})'
                  className="bg-white/5 border-white/10 text-white placeholder:text-white/50"
                />
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    className="border-white/20 text-white/80 flex-1"
                    disabled={!manualText || status === 'processing'}
                    onClick={() => handleScan(manualText.trim()).catch(() => {})}
                  >
                    Verify QR Manually
                  </Button>

                  <Button
                    variant="outline"
                    className="border-white/20 text-white/80"
                    onClick={doReset}
                  >
                    Reset
                  </Button>
                </div>
              </div>

              {/* WalletConnect QR & debug info */}
              <div className="w-full pt-2">
                <div className="min-h-[180px] border border-white/5 rounded p-3 flex flex-col items-center justify-center">
                  {wcQrDataUrl ? (
                    <>
                      <img src={wcQrDataUrl} alt="WalletConnect QR" style={{ width: 200, height: 200 }} />
                      <div className="text-sm text-white/70 mt-2">Status: {wcStatus}</div>
                    </>
                  ) : (
                    <div className="text-white/50">WalletConnect QR will appear here after scan request.</div>
                  )}
                </div>

                <div className="mt-3 text-left text-xs text-white/70">
                  <div>Challenge expires in: {expiresIn ?? '—'}s</div>
                  <div>Ticket: {ticketId ?? '—'}</div>
                  <div>VerificationId: {verificationId ?? '—'}</div>
                  <div>Signature: {signature ? <span className="break-words">{signature}</span> : '—'}</div>
                  <div>Signer: {signerPubkey ?? '—'}</div>
                </div>

                <div className="mt-3">
                  <div className="text-left text-sm text-white/80">Verify result:</div>
                  <pre className="text-xs text-white/70 max-h-36 overflow-auto p-2 bg-white/2 rounded mt-2">{JSON.stringify(verifyResult, null, 2)}</pre>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}